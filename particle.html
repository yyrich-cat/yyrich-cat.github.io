<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子</title>
    <style>
        body {
            margin: 0;
        }
        canvas {
            background-color: black;
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas>您的浏览器不支持canvas</canvas>
    <script>
        const canvas = document.getElementsByTagName("canvas")[0];
        const c = canvas.getContext("2d", { willReadFrequently : true });
        function initCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        initCanvasSize();

        /**
         * 获取 【min, max】 之间的随机数
         */
        function getRandom(min, max) {
            return Math.floor(Math.random()*(max + 1 - min) + min);
        }
        class PointA {
            constructor (x, y, alpha) {
                this.x = x;
                this.y = y;
                this.alpha = alpha;
            }
        }
        class Particle {
            constructor (a = 0, b = 360) {
                const r = Math.min(canvas.width, canvas.height) / 2;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const rad = getRandom(a, b) * Math.PI / 180;
                
                this.x = centerX + r * Math.cos(rad);
                this.y = centerY + r * Math.sin(rad);
                this.size = getRandom(this.minSize, this.maxSize);
            }
            draw () {
                const getAlpha = () => {
                    const cha = this.maxSize - this.minSize;
                    // 85 == hex"55"
                    const alpha = 85 + 170 - (this.size - this.minSize) * 170 / cha
                    return alpha;
                }
                c.beginPath();
                c.fillStyle = "#ff80f5" + getAlpha().toString(16);
                c.arc(this.x, this.y, this.size, 0, Math.PI*2);
                c.fill();
            }
            moveTo (p = new PointA, duration = 5000, delay = 0) {
                delay = delay || this.size * getRandom(0, 3000);
                const startX = this.x;
                const startY = this.y;
                const startTime = Date.now() + delay;
                const move = () => {
                    const raf = () => {
                        requestAnimationFrame(move);
                        return t / duration;
                    }
                    const t = Date.now() - startTime;
                    let per = (t / duration) > 1 ? 1 : raf();
                    per = per < 0 ? 0 : per;
                    this.x = startX + (p.x - startX) * per;
                    this.y = startY + (p.y - startY) * per;
                }
                move();
            }
        }
        Particle.prototype.maxSize = 3;
        Particle.prototype.minSize = 1;
        const particles = [new Particle];

        function draw() {
            clear();
            update();
            particles.forEach((p) => { p.draw(); });
            requestAnimationFrame(draw);
        }
        draw();

        function clear() {
            c.clearRect(0,0,canvas.width,canvas.height);
        }
        var text = "";
        var newText = location.href.split('?')[1] || "Hello World";
        newText = decodeURI(newText);

        function update () {
            if (text == newText) {
                return;
            }
            text = newText;
            c.fillStyle = "#fff";
            c.textBaseline = 'middle';
            c.textAlign = 'center';
            c.font = "70px Arial";
            c.fillText(text, canvas.width/2, canvas.height/2);
            const points = getPoints();
            clear()
            const length = points.length;
            particles.length = 0;
            for (let index = 0; index < length; index++) {
                const element = points[index];
                let p = new Particle;
                particles.push(p);
                p.moveTo(element, length, 2*getRandom(index,length));
            }
        }

        function getPoints() {
            const points = c.getImageData(0,0,canvas.width,canvas.height);
            const result = [];
            const gap = 2;
            for (let i = 0; i < points.width; i+=gap) {
                for (let j = 0; j < points.height; j+=gap) {
                    const index = (i + j * points.width) * 4;
                    const r = points.data[index];
                    const g = points.data[index + 1];
                    const b = points.data[index + 2];
                    const a = points.data[index + 3];
                    if (r == 255 && b == 255 && g == 255) {
                        result.push(new PointA(i, j, a));
                    }
                }
            }
            return result;
        }
        
    </script>
</body>
</html>